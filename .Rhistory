########################################################################
# Build and plot a regression tree
########################################################################
library(rpart.plot)
library(rpart)
# Basic partition tree model to plot
binary.model <- rpart(ontime_grad ~ scale_score_7_math +
pct_days_absent_7 + ell_7 + iep_7 + frpl_7 + male +
race_ethnicity +
sch_g7_lep_per + sch_g7_gifted_per,
data = sea_data,
control = rpart.control(cp = .005))
# Pass the model object to the plot function
# You can look at ?rpart.plot to identify customizations you wish to use
rpart.plot(binary.model)
# To improve the labels, you can rename the variables in the data
sea_data$short_race_label <- NA
sea_data$short_race_label[sea_data$race_ethnicity == "Hispan..."] <- "H"
sea_data$short_race_label[sea_data$race_ethnicity == "White"] <- "W"
sea_data$short_race_label[sea_data$race_ethnicity == "Asian"] <- "A"
sea_data$short_race_label[sea_data$race_ethnicity == "Americ..."] <- "AI"
sea_data$short_race_label[sea_data$race_ethnicity == "Demogg..."] <- "M"
sea_data$short_race_label[sea_data$race_ethnicity == "Native..."] <- "HA"
sea_data$short_race_label[sea_data$race_ethnicity == "Black ..."] <- "B"
# Fit a classification model, just like a logistic regression formula interface
binary.model <- rpart(ontime_grad ~ scale_score_7_math +
pct_days_absent_7 + ell_7 + iep_7 + frpl_7 + male +
short_race_label +
sch_g7_lep_per + sch_g7_gifted_per,
data = sea_data,
control = rpart.control(cp = .005))
# Make a plot showing the tree
rpart.plot(binary.model)
########################################################################
## Variable importance from a caret/train model object
########################################################################
## Fit a simple model just to show the syntax, you should be fitting a model
## split on train and test data, substitute your own model here.
# Unfortunately, we have to remove NAs first, because
# caret won't do it for us
train_data <- na.omit(sea_data[, c("ontime_grad", "scale_score_7_math",
"pct_days_absent_7", "ell_7", "iep_7",
"male", "frpl_7", "race_ethnicity",
"sch_g7_lep_per", "sch_g7_gifted_per")])
# Outcome must be a factor in R to work with caret, so we recode
# Avoid 0/1 factor labels - this causes problems in fitting many model types.
train_data$ontime_grad <- ifelse(train_data$ontime_grad == 1, "Grad", "Nongrad")
train_data$ontime_grad <- factor(train_data$ontime_grad)
# Fit the model
caret_mod <- train(ontime_grad ~ .,
method = "rpart",
data = train_data,
metric = "AUC",
trControl = trainControl(summaryFunction = prSummary,
classProbs = TRUE,
method = "cv"))
########################################################################
## Variable importance from a caret/train model object
########################################################################
## Fit a simple model just to show the syntax, you should be fitting a model
## split on train and test data, substitute your own model here.
# Unfortunately, we have to remove NAs first, because
# caret won't do it for us
train_data <- na.omit(sea_data[, c("ontime_grad", "scale_score_7_math",
"pct_days_absent_7", "ell_7", "iep_7",
"male", "frpl_7", "race_ethnicity",
"sch_g7_lep_per", "sch_g7_gifted_per")])
# Outcome must be a factor in R to work with caret, so we recode
# Avoid 0/1 factor labels - this causes problems in fitting many model types.
train_data$ontime_grad <- ifelse(train_data$ontime_grad == 1, "Grad", "Nongrad")
train_data$ontime_grad <- factor(train_data$ontime_grad)
# Fit the model
caret_mod <- train(ontime_grad ~ .,
method = "rpart",
data = train_data,
metric = "ROC",
trControl = trainControl(summaryFunction = twoClassSummary,
classProbs = TRUE,
method = "cv"))
# Get variable importance, not available for all methods
caret::varImp(caret_mod)
# Plot variable importance
plot(caret::varImp(caret_mod))
########################################################################
## Probablity accuracy
## Plot the relationship between predicted probabilities and observed
## graduation rates to explore thresholds.
########################################################################
library(yardstick)
library(dplyr)
# Get the predicted classifications from the caret model above
class_vec <- predict(caret_mod, newdata = train_data)
# Get the predicted probabilities from the model above
## Note that caret insists on giving probabilities for both classes, we
## need to store only one, in this case, the first one
prob_vec <- predict(caret_mod, newdata = train_data, type = "prob")[[1]] # only need first column
# Combine the true values, the estimated class, and the class probability
# into one dataframe for plotting
estimates_tbl <- data.frame(
truth = as.factor(train_data$ontime_grad),
estimate = as.factor(class_vec),
class_prob = prob_vec
)
# Using this struture we can use the `yardstick` package to nicely
# compute a variety of performanc emetrics
## Confusion matrix
estimates_tbl %>% yardstick::conf_mat(truth, estimate)
# Accuracy
estimates_tbl %>% yardstick::metrics(truth, estimate)
# AUC
estimates_tbl %>% yardstick::roc_auc(truth, class_prob)
# ROC graph
# Plots the ROC curve (the ROC at all possible threshold values for the
# probability cutoff)
estimates_tbl %>%
roc_curve(truth, class_prob) %>%
autoplot()
# Save the confusion matrix as an R object
conf_mat <- estimates_tbl %>% yardstick::conf_mat(truth, estimate)
# Plot the confusion matrix if you like
library(vcd)
labs <- round(prop.table(conf_mat$table), 2)
# Can change the margin to change the labels
mosaic(conf_mat$table, pop=FALSE)
labeling_cells(text = labs, margin = 0)(conf_mat$table)
################################################################################
## Probability vs. outcome plot for predicted probabilities
################################################################################
plotdf <- estimates_tbl %>%
mutate(prob_cut = percent_rank(class_prob)) %>%
# depending on how many unique probabilities your model produces you can try
# mutate(prob_cut = ntile(class_prob, 50)) %>%
group_by(prob_cut) %>%
summarize(
avg_prob = mean(class_prob),
prob_grad = sum(truth == "Grad") / length(truth),
count = n())
library(ggplot2)
library(ggalt) # for fun lollipop charts
ggplot(plotdf, aes(x = avg_prob, y = prob_grad)) +
ggalt::geom_lollipop() + theme_classic() +
coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), expand=FALSE) +
geom_smooth(se=FALSE)
################################################################################
## Advanced: Make a Bowers plot
#################################################################################
bowers_plot() +
# Add your annotation here:
annotate(geom = "point",
x = 1 - pull(estimates_tbl %>% yardstick::spec(truth, estimate)),
y = pull(estimates_tbl %>% yardstick::sens(truth, estimate)),
size = 5, color = "red")
# Use a custom probability threshold
# Set options for knitr
library(knitr)
knitr::opts_chunk$set(comment = NA, warning = FALSE, echo = TRUE,
root.dir = normalizePath("../"),
error = FALSE, message = FALSE, fig.align = 'center',
fig.width = 8, fig.height = 6, dpi = 144,
fig.path = "../figure/pa_",
cache.path = "../cache/pa_")
options(width = 80)
# Load the packages you need
library(dplyr)
library(pROC)
library(devtools)
library(future)
# Load the helper functions not in packages
source("../R/functions.R")
# Read in the data
# This command assumes that the data is in a folder called data, below your
# current working directory. You can check your working directory with the
# getwd() command, and you can set your working directory using the RStudio
# environment, or the setwd() command.
load("../data/montucky.rda")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$sid == sea_data$sid[[1]]) # test how many times the first sid appears
length(unique(sea_data$sch_g7_lea_id)) # test how many LEAs are in our data
nrow(sea_data) == n_distinct(sea_data$sid, sea_data$sch_g7_lea_id)
sea_data$sid <- paste(sea_data$sid, sea_data$sch_g7_lea_id, sep = "-")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$year)
table(sea_data$cohort_year)
table(sea_data$cohort_grad_year)
table(sea_data$year_of_graduation == sea_data$cohort_grad_year)
table(sea_data$ontime_grad)
table(sea_data$year_of_graduation <= sea_data$cohort_grad_year + 1)
length(unique(sea_data$first_hs_name))
length(unique(sea_data$first_hs_lea_id))
table(sea_data$coop_name_g7, useNA = "always")
my_coop <- sea_data$coop_name_g7[50] # select the coop for the 50th observation
# Which districts are in this coop and how many 7th graders do we have for each?
table(sea_data$sch_g7_lea_id[sea_data$coop_name_g7 == my_coop],
useNA = "always")
# which schools?
table(sea_data$sch_g7_name[sea_data$coop_name_g7 == my_coop],
useNA = "always")
table(sea_data$male, useNA="always")
# Set options for knitr
library(knitr)
knitr::opts_chunk$set(comment = NA, warning = FALSE, echo = TRUE,
root.dir = normalizePath("../"),
error = FALSE, message = FALSE, fig.align = 'center',
fig.width = 8, fig.height = 6, dpi = 144,
fig.path = "../figure/pa_",
cache.path = "../cache/pa_")
options(width = 80)
# Load the packages you need
library(dplyr)
library(pROC)
library(devtools)
library(future)
# Load the helper functions not in packages
source("../R/functions.R")
# Read in the data
# This command assumes that the data is in a folder called data, below your
# current working directory. You can check your working directory with the
# getwd() command, and you can set your working directory using the RStudio
# environment, or the setwd() command.
load("../data/montucky.rda")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$sid == sea_data$sid[[1]]) # test how many times the first sid appears
length(unique(sea_data$sch_g7_lea_id)) # test how many LEAs are in our data
nrow(sea_data) == n_distinct(sea_data$sid, sea_data$sch_g7_lea_id)
sea_data$sid <- paste(sea_data$sid, sea_data$sch_g7_lea_id, sep = "-")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$year)
table(sea_data$cohort_year)
table(sea_data$cohort_grad_year)
table(sea_data$year_of_graduation == sea_data$cohort_grad_year)
table(sea_data$ontime_grad)
table(sea_data$year_of_graduation <= sea_data$cohort_grad_year + 1)
length(unique(sea_data$first_hs_name))
length(unique(sea_data$first_hs_lea_id))
table(sea_data$coop_name_g7, useNA = "always")
my_coop <- sea_data$coop_name_g7[50] # select the coop for the 50th observation
# Which districts are in this coop and how many 7th graders do we have for each?
table(sea_data$sch_g7_lea_id[sea_data$coop_name_g7 == my_coop],
useNA = "always")
# which schools?
table(sea_data$sch_g7_name[sea_data$coop_name_g7 == my_coop],
useNA = "always")
table(sea_data$male, useNA="always")
names(sea_data)
install.packages('widyr')
install.packages('widyr')
library(widyr)
sea_data %>% pairwise_count(frpl_7, coop_name_g7)
sea_data %>% pairwise_count(coop_name_g7, frpl_7)
sea_data %>% pairwise_count(coop_name_g7, frpl_7)
head(sea_data$frpl_7)
?pairwise_count
sea_data %>% pairwise_count(coop_name_g7, frpl_7)
sea_data %>% pairwise_count(coop_name_g7, race_ethnicity)
sea_data %>% ungroup %>% pairwise_count(coop_name_g7, race_ethnicity)
sea_data %>% ungroup %>% pairwise_count(race_ethnicity,coop_name_g7)
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n())%>%
kable()
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n()) %>%
kable()
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n()) %>%
mutate(per = n / sum(n)) %>%
kable()
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n)), 2) %>%
kable()
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n)), 2) %>%
kable()
sea_data %>%
group_by(coop_name_g7, race_ethnicity)%>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable()
prop.table( # convert table to percentages
table(sea_data$coop_name_g7, sea_data[, "race_ethnicity"],  # build the table
useNA = "always"),
margin = 1)
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, !!var)%>%
summarize(n=n()) %>% `
mutate(per = round(n / sum(n), 2)) %>%
kable()
}
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, !!var)%>%
summarize(n=n()) %>% `
mutate(per = round(n / sum(n), 2)) %>%
kable()
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, !!var) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable()
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, !!var) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, get(var)) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7, var = get(var)) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7) %>%
group_by(!!var) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(coop_name_g7) %>%
group_by(!!!var) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
sea_data %>%
group_by(!!!var) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
var_enq <- rlang::sym(var)
sea_data %>%
group_by(!!var_enq) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
for(var in c("male", "race_ethnicity", "frpl_7", "iep_7", "ell_7",
"gifted_7")){
var_enq <- rlang::sym(var)
sea_data %>%
group_by(coop_name_g7, !!var_enq) %>%
summarize(n=n()) %>%
mutate(per = round(n / sum(n), 2)) %>%
kable() %>% print
}
?group_walk
# Set options for knitr
library(knitr)
knitr::opts_chunk$set(comment = NA, warning = FALSE, echo = TRUE,
root.dir = normalizePath("../"),
error = FALSE, message = FALSE, fig.align = 'center',
fig.width = 8, fig.height = 6, dpi = 144,
fig.path = "../figure/pa_",
cache.path = "../cache/pa_")
options(width = 80)
# Load the packages you need
library(dplyr)
library(pROC)
library(devtools)
library(future)
# Load the helper functions not in packages
source("../R/functions.R")
# Read in the data
# This command assumes that the data is in a folder called data, below your
# current working directory. You can check your working directory with the
# getwd() command, and you can set your working directory using the RStudio
# environment, or the setwd() command.
load("../data/montucky.rda")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$sid == sea_data$sid[[1]]) # test how many times the first sid appears
length(unique(sea_data$sch_g7_lea_id)) # test how many LEAs are in our data
nrow(sea_data) == n_distinct(sea_data$sid, sea_data$sch_g7_lea_id)
sea_data$sid <- paste(sea_data$sid, sea_data$sch_g7_lea_id, sep = "-")
nrow(sea_data) == n_distinct(sea_data$sid)
table(sea_data$year)
table(sea_data$cohort_year)
table(sea_data$cohort_grad_year)
table(sea_data$year_of_graduation == sea_data$cohort_grad_year)
table(sea_data$ontime_grad)
table(sea_data$year_of_graduation <= sea_data$cohort_grad_year + 1)
length(unique(sea_data$first_hs_name))
length(unique(sea_data$first_hs_lea_id))
table(sea_data$coop_name_g7, useNA = "always")
my_coop <- sea_data$coop_name_g7[50] # select the coop for the 50th observation
# Which districts are in this coop and how many 7th graders do we have for each?
table(sea_data$sch_g7_lea_id[sea_data$coop_name_g7 == my_coop],
useNA = "always")
# which schools?
table(sea_data$sch_g7_name[sea_data$coop_name_g7 == my_coop],
useNA = "always")
table(sea_data$male, useNA="always")
table(sea_data$ontime_grad, useNA = "always")
table(sea_data$transferout, useNA = "always")
table(transfer = sea_data$transferout, grad = sea_data$ontime_grad, useNA = "always")
summary(sea_data$vendor_ews_score)
set_thresh <- 0.5
conf_count <- table(observed = sea_data$ontime_grad,
pred = sea_data$vendor_ews_score > set_thresh)
conf_count
set_thresh <- mean(sea_data$vendor_ews_score)
conf_count <- table(observed = sea_data$ontime_grad,
pred = sea_data$vendor_ews_score > set_thresh)
conf_count
# Create a proportion table and round for easier interpretation
round(prop.table(conf_count), digits = 3)
summary(sea_data$scale_score_7_math)
hist(sea_data$scale_score_7_math)
# TODO: Replace this with a visualization
by(sea_data$scale_score_7_math, sea_data$coop_name_g7, FUN = mean,
na.rm = TRUE)
by(sea_data$scale_score_7_math, sea_data$frpl_7, FUN = mean,
na.rm = TRUE)
effect_size_diff(x = sea_data$scale_score_7_math,
group_idx = sea_data$ontime_grad,
na.rm = TRUE)
effect_size_diff(x = sea_data$pct_days_absent_7,
group_idx = sea_data$ontime_grad,
na.rm = TRUE)
sea_data$pct_absent_cat <- round(sea_data$pct_days_absent_7, digits = 0)
table(sea_data$pct_absent_cat)
sea_data$pct_absent_cat[sea_data$pct_absenct_cat >= 30] <- 30
library(ggplot2)
# TODO - Update this plot sequence to ggplot2
plotdf <- sea_data %>%
group_by(pct_absent_cat) %>% # perform the operation for each value
summarize(abs_ontime_grad = mean(ontime_grad, na.rm = TRUE)) %>% # add a new variable
as.data.frame()
ggplot(plotdf, aes(x = pct_absent_cat, y = abs_ontime_grad)) +
geom_point() + theme_bw()
ggplot(sea_data) + aes(scale_score_7_math) +
geom_histogram(bins = 100)
sea_data$scale_score_7_math[sea_data$scale_score_7_math < 0] <- NA
ggplot(sea_data) + aes(scale_score_7_math) +
geom_histogram(bins = 100)
plotdf <- sea_data %>%
mutate(math_7_cut = ntile(scale_score_7_math, n = 100)) %>%
group_by(math_7_cut) %>% # perform the operation for each value
summarize(math_7_ontime_grad = mean(ontime_grad, na.rm=TRUE)) %>% # add a new variable
as.data.frame()
ggplot(plotdf) + aes(x = math_7_cut, y = math_7_ontime_grad) +
geom_point() +
theme_bw()
for(var in c("coop_name_g7", "male", "race_ethnicity")){
print(var)
sum_table <- table(sea_data[, var],
"missing_math" = is.na(sea_data$pct_days_absent_7))
sum_table <- prop.table(sum_table, 1)
print(round(sum_table, digits = 3))
}
ggplot(sea_data) + aes(x = pct_days_absent_7) +
geom_histogram(bins = 100)
sea_data$pct_days_absent_7[sea_data$pct_days_absent_7 > 100] <- NA
ggplot(sea_data) + aes(x = pct_days_absent_7) +
geom_histogram(bins = 100)
# Count NAs
sum(is.na(sea_data$ontime_grad))
sum(is.na(sea_data$scale_score_7_math))
# TODO - explain missing data handling here? # 1354 observations are deleted
math_model <- glm(ontime_grad ~ scale_score_7_math, data = sea_data,
family = "binomial") # family tells R we want to fit a logistic
summary(math_model)
logit_rsquared(math_model)
math_model2 <- glm(ontime_grad ~ scale_score_7_math +
scale_score_7_math^2 +
scale_score_7_math^3,
data = sea_data,
family = "binomial") # family tells R we want to fit a logistic
logit_rsquared(math_model2)
summary(math_model2)
math_model2 <- glm(ontime_grad ~ scale_score_7_math +
I(scale_score_7_math^2) +
I(scale_score_7_math^3),
data = sea_data,
family = "binomial") # family tells R we want to fit a logistic
logit_rsquared(math_model2)
summary(math_model2)
